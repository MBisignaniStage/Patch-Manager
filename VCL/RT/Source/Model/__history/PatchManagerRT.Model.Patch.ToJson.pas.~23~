unit PatchManagerRT.Model.Patch.ToJson;

interface
uses
  PatchManagerRT.Controller.Interfaces,
  System.JSON,
  System.Classes,
  System.SysUtils,
  System.Generics.Collections,
  PatchManagerRT.Model.Interfaces;


type
  TPatchManagerRTModelPatchToJson = class(TInterfacedObject , IPatchManagerRTModelPatch)
  strict private
    FEntity : IPatchManagerRTControllerPatchEntity;
    FLog: IPatchManagerRTControllerPatchLog;
    FListEntity : TList<IPatchManagerRTControllerPatchEntity>;
    FListLog : Tlist<IPatchManagerRTControllerPatchLog>;
    FErrors : TStringList;
  public
    procedure Entity(const AValue : IPatchManagerRTControllerPatchEntity);
    procedure Log(const AValue : IPatchManagerRTControllerPatchLog);
    function Save: boolean;
    function Insert: boolean;
    function GetJsonPatch: string;
    function GetLog : String;
    function Load : TList<String>;
    constructor Create;
    destructor Destroy; override;
    class function New: IPatchManagerRTModelPatch;
  end;

implementation

uses
  Rest.Json,
  System.IOUtils,
  PatchManagerRT.Controller.Factory,
  PatchManagerRT.Controller.Patch.Entity,
  System.Rtti;


{ TPatchManagerRTModelPatchToJson }

constructor TPatchManagerRTModelPatchToJson.Create;
begin
    FErrors := TStringList.Create;
    FEntity := TPatchManagerRTControllerFactory.New.Entity;
    FLog := TPatchManagerRTControllerFactory.new.log;
    FListEntity := TList<IPatchManagerRTControllerPatchEntity>.Create;
    FlistLog := Tlist<IPatchManagerRTControllerPatchLog>.Create;
end;

destructor TPatchManagerRTModelPatchToJson.Destroy;
begin
if Assigned(FErrors) then
  FErrors.Free;
if Assigned(FListEntity) then
  FListEntity.Free;
if Assigned(FListLog) then
  FListLog.free;
  inherited;
end;

procedure TPatchManagerRTModelPatchToJson.Entity(
  const AValue: IPatchManagerRTControllerPatchEntity);
begin
  FEntity :=  AValue;
end;
//prova importazione dati da file json da utilizzare successivamente
function TPatchManagerRTModelPatchToJson.Load: TList<String>;
var
  LFileStream : TFileStream;
  LJsonStream : TStringStream;
  LList : TList<String>;
  LJsonValue : TJSONValue;
  LValori : TJSONArray;
  I : integer;
begin
  LJsonStream := TStringStream.Create;
  try
    LFileStream := TFileStream.create('C:\PatchManagerOUT\prova.json', 0);
      try
        LJsonStream.LoadFromStream(LFileStream);
      finally
        LFileStream.Free;
      end;
    LJsonValue := TJSONObject.ParseJSONValue(LJsonStream.DataString);
    LList := TList<String>.Create;
    try
      LValori := LJsonValue.GetValue<TJSONArray>('Patches');
      for I := 0 to LValori.count - 1 do
      LList.add(LValori.Items[I].GetValue<string>('Command'));
      Result := LList;
    finally
    LjsonValue.free;
    LList.free;
    end;
  finally
  LJsonStream.free;
  end;
end;

procedure TPatchManagerRTModelPatchToJson.Log(
  const AValue: IPatchManagerRTControllerPatchLog);
begin
  FLog := AValue;
end;
//Restituisce i log, da fare domani
function TPatchManagerRTModelPatchToJson.GetLog : string;
begin
Result := '[' + FListLog.First.Created +']'+ ' ' + FListLog.first.LogType;
end;
//restitutisce la patch json formattata
function TPatchManagerRTModelPatchToJson.GetJsonPatch: string;
var
RootObject : TJSONObject;
LJSONArray : TJSONArray;
LTmpJson : TJSONValue;
LEntity : IPatchManagerRTControllerPatchEntity;
begin
  Result := '';
  if FListEntity.IsEmpty then
  exit;
  RootObject := TJSONObject.Create;
  try
    RootObject.AddPair('Created', FListEntity[0].Created);
    RootObject.AddPair('DbType', FEntity.DbType);
    LJSONArray := TJSONArray.Create;
    for LEntity in FListEntity  do
      LJSONArray.add(LEntity.ToJSON);
      RootObject.addpair('Patches',LJSONArray);
      LTmpJson := TJSONObject.ParseJSONValue(RootObject.ToJSON);
      try
      Result := TJson.format(LTmpJson);
      finally
      LTmpJson.free;
      end;
  finally
  RootObject.free;
  end;
end;
//Inserisce la entity(patch) all'interno della lista
function TPatchManagerRTModelPatchToJson.Insert: boolean;
var
  LEntity : IPatchManagerRTControllerPatchEntity;
  LGUID : TGUID;
  prova :string;
begin
prova := '';
//I campi non possono essere vuoti
  if FEntity.Description.IsEmpty or
    FEntity.Command.IsEmpty or
    FEntity.DbType.IsEmpty   then
  begin
    Result := false;
  exit
  end;
  try
  CreateGUID(LGUID);
  FEntity.PatchId(LGUID);
  FEntity.Created(FormatDateTime('yyyy-mm-dd hh:nn:ss.zzz',now));
  LEntity := TPatchManagerRTControllerFactory.New.Entity;
  LEntity.CopyEntity(FEntity);
  FListEntity.add(LEntity);
  except
      on e : Exception do
      begin
        Result := False;
        FErrors.add(e.message);
      end;
  end;
  flog.Created(FormatDateTime('yyyy-mm-dd hh:nn:ss.zzz',now));
  FLog.LogType('Inserimento effettuato di'+ ' ' + FEntity.Description);
  FListLog.Add(FLog);
  Result := True;
end;


//Salva il file json contentente le varie patch
function TPatchManagerRTModelPatchToJson.Save: boolean;
var
LPatchJson : string;
begin
  try
  LPatchJson := GetJsonPatch;
  Tfile.WriteAllText('prova.json', LPatchJson);
  except
    on e: Exception do
    begin
        Result := False;
        FErrors.add(e.Message);
    end;
  end;
  Result := true;
end;

class function TPatchManagerRTModelPatchToJson.New: IPatchManagerRTModelPatch;
begin
  Result := Self.Create;
end;

end.
